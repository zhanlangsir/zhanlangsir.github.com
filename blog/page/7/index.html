
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>挨踢人生</title>
  <meta name="author" content="zhanlang">

  
  <meta name="description" content="原因：
linux默认安装将会把中文区域设置为zh_CN.utf8，而GVim能识别的中文区域设置为zh_CN.UTF-8。因此GVim会在启动时报错，且无法正常加载中文菜单。 解决方案：
代码:
cd /usr/share/vim/vim72/lang&lt;br&gt;sudo ln -s &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://zhanlangsir.github.com/blog/page/7/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="挨踢人生" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">挨踢人生</a></h1>
  
    <h2>做一个有思想的人</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:zhanlangsir.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/04/10/gvim-gtk-warning-invalid-input-string-warning/">Gvim 菜单无法显示( Gtk-WARNING **: Invalid Input String)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-04-10T00:00:00+08:00" pubdate data-updated="true">Apr 10<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>原因：<br/>
linux默认安装将会把中文区域设置为zh_CN.utf8，而GVim能识别的中文区域设置为zh_CN.UTF-8。因此GVim会在启动时报错，且无法正常加载中文菜单。</p>

<p>解决方案：<br/>
代码:<br/>
<code>cd /usr/share/vim/vim72/lang&lt;br&gt;sudo ln -s menu_zh_cn.utf-8.vim menu_zh_cn.utf8.vim</code></p>

<p>此方法使得GVim可以识别zh_CN.utf8，并采用于zh_CN.UTF-8完全相同的菜单设置。并且不影响系统的中文区域设置。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/04/10/google-cpp-code-style/">Google C++ 代码风格规范</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-04-10T00:00:00+08:00" pubdate data-updated="true">Apr 10<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>好的代码风格规范是衡量一个优秀的程序员必要条件，如果代码有比较好的风格规范，那么阅读者能够一目了然，反之，则需要花费大量的时间去读懂代码。<br/>
所以，相当程序员的童鞋就有必要养成良好的代码风格习惯，这样才能在以后的团队项目开发中发挥更大的作用。<br/>
下面是Google使用的C++代码规范，童鞋们可以参考一下，但是也不必全部照做，因为代码风格并没有一个统一的标准。例如微软也有自己的一套标准，所以应该是饱着“取其精华,弃其糟粕”的心态去学习~</p>

<p><a href="http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml">googloe c++ code style</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/04/10/gcc-useage-detail-2/">GCC使用详解(2)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-04-10T00:00:00+08:00" pubdate data-updated="true">Apr 10<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>代码优化</h2>

<p>代码优化指的是编译器通过分析源代码,找出其中尚未达到最优的部分,然后对其重新进行组合,目的是改善程序的执行性能。GCC提供的代码优化功能非常强 大,它通过编译选项-On来控制优化代码的生成,其中n是一个代表优化级别的整数。对于不同版本的GCC来讲,n的取值范围及其对应的优化效果可能并不完 全相同,比较典型的范围是从0变化到2或3。</p>

<p>编译时使用选项-O可以告诉GCC同时减小代码的长度和执行时间,其效果等价于-O1。在这一级别上能够进行的优化类型虽然取决于目标处理器,但一般都会 包括线程跳转（Thread Jump）和延迟退栈（Deferred Stack Pops）两种优化。选项-O2告诉GCC除了完成所有-O1级别的优化之外,同时还要进行一些额外的调整工作,如处理器指令调度等。选项-O3则除了完 成所有-O2级别的优化之外,还包括循环展开和其它一些与处理器特性相关的优化工作。通常来说,数字越大优化的等级越高,同时也就意味着程序的运行速度越 快。许多Linux程序员都喜欢使用-O2选项,因为它在优化长度、编译时间和代码大小之间,取得了一个比较理想的平衡点。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2011/04/10/gcc-useage-detail-2/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/04/10/gcc-useage-detail-1/">GCC使用详解(1)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-04-10T00:00:00+08:00" pubdate data-updated="true">Apr 10<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p> 
在为Linux开发应用程序时,绝大多数情况下使用的都是C语言,因此几乎每一位Linux程序员面临的首要问题都是如何灵活运用C编译器。目前Linux下最常用的C语言编译器是GCC（GNU Compiler Collection）,它是GNU项目中符合ANSI C标准的编译系统,能够编译用C、C++和Object C等语言编写的程序。GCC不仅功能非常强大,结构也异常灵活。最值得称道的一点就是它可以通过不同的前端模块来支持各种语言,如Java、Fortran、Pascal、Modula-3和Ada等。</p>

<p>开放、自由和灵活是Linux的魅力所在,而这一点在GCC上的体现就是程序员通过它能够更好地控制整个编译过程。在使用GCC编译程序时,编译过程可以被细分为四个阶段：<br/>
预处理（Pre-Processing）<br/>
编译（Compiling）<br/>
汇编（Assembling）<br/>
链接（Linking）[more]<br/>
Linux程序员可以根据自己的需要让GCC在编译的任何阶段结束,以便检查或使用编译器在该阶段的输出信息,或者对最后生成的二进制文件进行控制,以便通过加入不同数量和种类的调试代码来为今后的调试做好准备。和其它常用的编译器一样,GCC也提供了灵活而强大的代码优化功能,利用它可以生成执行效率更高的代码。</p>

<p>GCC提供了30多条警告信息和三个警告级别,使用它们有助于增强程序的稳定性和可移植性。此外,GCC还对标准的C和C++语言进行了大量的扩展,提高程序的执行效率,有助于编译器进行代码优化,能够减轻编程的工作量。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2011/04/10/gcc-useage-detail-1/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/04/10/cpp-xml-library/">c++XML库</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-04-10T00:00:00+08:00" pubdate data-updated="true">Apr 10<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在C++中，库的地位是非常高的，各种各样的库极大的扩展了C++的功能，一个设计的好的库，让你对C++的使用更加得心应手，现在我们介绍的就是xml操作的库~请看接下来的介绍！</p>

<p>C++各大有名库的介绍——XML</p>

<ol>
<li><p><a href="http://xml.apache.org/xerces-c/">Xerces</a><br/>
Xerces-C++ 是一个非常健壮的XML解析器，它提供了验证，以及SAX和DOM API。XML验证在文档类型定义(Document Type Definition，DTD)方面有很好的支持，并且在2001年12月增加了支持W3C XMLSchema 的基本完整的开放标准。
</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2011/04/10/cpp-xml-library/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/04/10/art-of-array-and-point-part-two/">数组与指针的艺术-第二章</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-04-10T00:00:00+08:00" pubdate data-updated="true">Apr 10<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p> </p>

<h2>数组名是一个指针常量吗？</h2>

<p>数组名是一个指针常量这种观点来源于数组名在表达式计算中与指针的结果等效性。例如下面的代码：</p>

<pre><code>int a[10], *p = a, *q;
q = a + 1;
q = p + 1;
</code></pre>

<p>在效果上看，a + 1与 p + 1是相同的，这很容易给人一种a就是p的假象，但，这仅仅是假象。鉴于指针常量包含了指针和常量两类概念，我们可以把这个问题分开两部分进行讨论。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2011/04/10/art-of-array-and-point-part-two/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/04/10/art-of-array-and-point-part-three/">数组与指针的艺术-第三章</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-04-10T00:00:00+08:00" pubdate data-updated="true">Apr 10<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>C/C++的数组不同于VB等语言的数组，是有层次的，这个层次指的不是维度，而是象俄罗斯有名的套娃一样，一维套一维，亦即数组的嵌套，数组的元素也是数组，VB等语言的数组与之相比更像一个平面。</p>

<p>数组嵌套这个现象从其它语言的角度来看有点奇特，但其实原因也很简单。C/C++的对象模型并不视数组为某种数值的简单集合，而是对象的聚集，每个元素都是一个对象。元素为整数对象，就是整数数组，为浮点数对象，就是浮点数数组。然而，数组本身也是一种对象，因此一个数组也能作为另一个数组的元素。当某个一维数组以一维数组作为元素时，这个一维数组每个元素都具有数组类型，这个一维数组其实是二维数组，同理，一个以二维数组作为元素的一维数组其实是三维数组。因此，使用C/C++数组的时候应该用数组嵌套的观点去看待。有人据此认为，C/C++的数组不是真正的数组，还有的认为C/C++没有多维数组，这些观点都有失偏颇，与其它语言的数组相比，两者只是同一事物的不同实例，是实现方法的不同，而本质是一样的，C/C++的数组嵌套可视为对数组概念的发展。</p>

<p>现在来看看数组的定义：</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2011/04/10/art-of-array-and-point-part-three/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/04/10/art-of-array-and-point-part-ten/">数组与指针的艺术-第十章(完)</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-04-10T00:00:00+08:00" pubdate data-updated="true">Apr 10<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>当写下这个题目的时候，笔者心里其实非常犯难。因为从本质上来说，本章想阐述的内容与题目所宣示的概念，其实是不一样的。在编程中，我们常常要处理一段长度未知的数据，而且，运行过程中长度可能会发生变化，现行的C/C++标准没有提供在栈段和数据段内存中的实现，只提供堆中的实现，例如可以象下面代码那样在堆中分配一段内存，以处理一组长度不确定的整数：</p>

<pre><code>int *p = ( int* )malloc( n * sizeof( int ) );
</code></pre>

<p>现在我们常常将这段堆内存称为&#8221;动态数组&#8221;。这正确吗？</p>

<p>数组是一个高层概念，是C/C++对象模型及类型系统的重要组成。一个对象欲成为一个数组，引用此对象的表达式或标识符必须具有高层的数组类型，但这段内存没有任何数组类型的引用，只有一个指向它的指针，因此，这段内存不是C/C++高层语义上的数组。虽然p可以使用下标运算符访问内存块中的数据，但其实只不过得益于下标运算符的指针性质（如第四章所述）而已。一个真正的动态数组，不仅长度在运行期内可变，还需要具备数组类型的抽象，这要求语言规则的支持，这些条件是p所不具备的。但是，真正的动态数组的实现也不容易，往往受到效率等多重因素的制约，即使实现了也可能需要付出很大的代价，得不偿失，正因如此，C/C++标准都没有提供对动态数组的支持。不过，这段堆内存被称为“动态数组”多年来已经习惯成自然了，笔者没有为其重新命名的技术能力和资历，也就只有随波逐流，暂且也称之为动态数组吧，重要的是明白两者本质的不同。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2011/04/10/art-of-array-and-point-part-ten/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/04/10/art-of-array-and-point-part-six/">数组与指针的艺术-第六章</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-04-10T00:00:00+08:00" pubdate data-updated="true">Apr 10<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>const一词在字面上来源于常量constant，const对象在C/C++中是有不同解析的，如第二章所述，在C中常量表达式必须是编译期，运行期的不是常量表达式，因此C中的const不是常量表达式；但在C++中，由于去掉了编译期的限定，因此是常量表达式。
对于一个指向const对象的指针pointer to const T，由于把const视作常量表达式，常常存在如下两种观点：</p>

<ol>
<li>这是一个指向常量的指针，简称常量指针；</li>
<li>这个指针指向的内容不可改变。</li>
</ol>


<p>这是比较粗糙的理解。虽然这个指针的类型是pointer to const T，但不代表它指向的对象真的是一个常量或者不可改变，例如：</p>

<pre><code>int i = 10;
const int *p = &amp;i;
i = 20;
</code></pre>

<p>p指向的对象i明显不是常量，虽然p指向i，但i的值依然可以改变。对于这个现象，C++标准有明确的论述：<br/>
7.1.5.1 The cv-qualifiers<br/>
a pointer or reference to a cv-qualified type need not actually point or refer to a cv-qualified object, but it is treated as if it does;<br/>
其中cv指的是const和volatile，const和volatile叫type qualifier，类型限定词。const T只是类型假定，并非指出该对象是什么，这个对象也许是const限定的，也许不是。既然上述两种看法都是不恰当的，pointer to const T又应如何看待呢？一种比较好的理解是，将其视作一条访问路径。对一个对象进行取值或者修改操作，可以有很多种方法，每种方法都相当于一条能够对对象进行访问的路径，例如：</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2011/04/10/art-of-array-and-point-part-six/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/04/10/art-of-array-and-point-part-seven/">数组与指针的艺术-第七章</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-04-10T00:00:00+08:00" pubdate data-updated="true">Apr 10<span>th</span>, 2011</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>首先看看如下一个声明：</p>

<pre><code>int* ( *( *fun )( int* ) )[10];
</code></pre>

<p>这是一个会让初学者感到头晕目眩、感到恐惧的函数指针声明。在熟练掌握C/C++的声明语法之前，不学习一定的规则，想理解好这类复杂声明是比较困难的。</p>

<p>C/C++所有复杂的声明结构，都是由各种声明嵌套构成的。如何解读复杂指针声明？右左法则是一个很著名、很有效的方法。不过，右左法则其实并不是C/C++标准里面的内容，它是从C/C++标准的声明规定中归纳出来的方法。C/C++标准的声明规则，是用来解决如何创建声明的，而右左法则是用来解决如何辩识一个声明的，从嵌套的角度看，两者可以说是一个相反的过程。右左法则的英文原文是这样说的：</p>

<blockquote><p>The right-left rule: Start reading the declaration from the innermost parentheses, go right, and then go left. When you encounter parentheses, the direction should be reversed. Once everything in the parentheses has been parsed, jump out of it. Continue till the whole declaration has been parsed.</p></blockquote>

<p>这段英文的翻译如下：<br/>
右左法则：首先从最里面的圆括号看起，然后往右看，再往左看。每当遇到圆括号时，就应该掉转阅读方向。一旦解析完圆括号里面所有的东西，就跳出圆括号。重复这个过程直到整个声明解析完毕。</p>

<p>笔者要对这个法则进行一个小小的修正，应该是从未定义的标识符开始阅读，而不是从括号读起，之所以是未定义的标识符，是因为一个声明里面可能有多个标识符，但未定义的标识符只会有一个。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2011/04/10/art-of-array-and-point-part-seven/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/8/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/blog/page/6/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>分类目录</h1>
  <ul id="category-list">
    <li><a href='/blog/categories/c-c-'>c/c++ (16)</a></li><li><a href='/blog/categories/dotnet'>DotNet (6)</a></li><li><a href='/blog/categories/linux'>linux (1)</a></li><li><a href='/blog/categories/linux'>Linux (13)</a></li><li><a href='/blog/categories/php'>php (6)</a></li><li><a href='/blog/categories/qt'>Qt (8)</a></li><li><a href='/blog/categories/vim'>Vim (12)</a></li><li><a href='/blog/categories/windows'>Windows (5)</a></li><li><a href='/blog/categories/其他'>其他 (5)</a></li><li><a href='/blog/categories/瞎折腾'>瞎折腾 (1)</a></li><li><a href='/blog/categories/网页设计'>网页设计 (3)</a></li><li><a href='/blog/categories/软件工具'>软件工具 (2)</a></li>
  </ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2012/12/28/octopress-add-categorylist-and-tagcloud/">给octopress添加Category和TagCloud</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/12/26/mutt-message-status-flags/">mutt消息状态标志</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/12/23/qtqq-v070-beta/">Qtqq v0.7.0-beta</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/12/23/qtqq-1223/">Qtqq 12/23</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/12/23/about-qtqqv080-alpha/">关于qtqq0.8.0-alpha</a>
      </li>
    
  </ul>
</section>
<section>
  <h1>Tag Cloud</h1>
    <span id="tag-cloud"><a href='/blog/categories/c-c-' style='font-size: 160.0%'>c/c++(16)</a> <a href='/blog/categories/dotnet' style='font-size: 122.5%'>DotNet(6)</a> <a href='/blog/categories/linux' style='font-size: 103.75%'>linux(1)</a> <a href='/blog/categories/linux' style='font-size: 148.75%'>Linux(13)</a> <a href='/blog/categories/php' style='font-size: 122.5%'>php(6)</a> <a href='/blog/categories/qt' style='font-size: 130.0%'>Qt(8)</a> <a href='/blog/categories/vim' style='font-size: 145.0%'>Vim(12)</a> <a href='/blog/categories/windows' style='font-size: 118.75%'>Windows(5)</a> <a href='/blog/categories/其他' style='font-size: 118.75%'>其他(5)</a> <a href='/blog/categories/瞎折腾' style='font-size: 103.75%'>瞎折腾(1)</a> <a href='/blog/categories/网页设计' style='font-size: 111.25%'>网页设计(3)</a> <a href='/blog/categories/软件工具' style='font-size: 107.5%'>软件工具(2)</a> </span>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/zhanlangsir">@zhanlangsir</a> on GitHub
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'zhanlangsir',
            count: 4,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>


  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2012 - zhanlang -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
